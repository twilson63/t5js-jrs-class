import acornJsx from 'acorn-jsx';
import MagicString from 'magic-string';

function __commonjs(fn, module) { return module = { exports: {} }, fn(module, module.exports), module.exports; }

var inject = __commonjs(function (module) {
'use strict';

module.exports = function(acorn) {
  var tt = acorn.tokTypes;
  var pp = acorn.Parser.prototype;

  // this is the same parseObj that acorn has with...
  function parseObj(isPattern, refDestructuringErrors) {
    var this$1 = this;

    var node = this.startNode(), first = true, propHash = {}
    node.properties = []
    this.next()
    while (!this$1.eat(tt.braceR)) {
      if (!first) {
        this$1.expect(tt.comma)
        if (this$1.afterTrailingComma(tt.braceR)) break
      } else first = false

      var prop = this$1.startNode(), isGenerator, startPos, startLoc
      if (this$1.options.ecmaVersion >= 6) {
        // ...the spread logic borrowed from babylon :)
        if (this$1.type === tt.ellipsis) {
          prop = this$1.parseSpread()
          prop.type = isPattern ? "RestProperty" : "SpreadProperty"
          node.properties.push(prop)
          continue
        }

        prop.method = false
        prop.shorthand = false
        if (isPattern || refDestructuringErrors) {
          startPos = this$1.start
          startLoc = this$1.startLoc
        }
        if (!isPattern)
          isGenerator = this$1.eat(tt.star)
      }
      this$1.parsePropertyName(prop)
      this$1.parsePropertyValue(prop, isPattern, isGenerator, startPos, startLoc, refDestructuringErrors)
      this$1.checkPropClash(prop, propHash)
      node.properties.push(this$1.finishNode(prop, "Property"))
    }
    return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression")
  }

  acorn.plugins.objectSpread = function objectSpreadPlugin(instance) {
    pp.parseObj = parseObj;
  };

  return acorn;
};
});

var acornObjectSpread = (inject && typeof inject === 'object' && 'default' in inject ? inject['default'] : inject);

var keys = {
	Program: [ 'body' ],
	Literal: []
};

// used for debugging, without the noise created by
// circular references
function toJSON ( node ) {
	var obj = {};

	Object.keys( node ).forEach( function ( key ) {
		if ( key === 'parent' || key === 'program' || key === 'keys' || key === '__wrapped' ) return;

		if ( Array.isArray( node[ key ] ) ) {
			obj[ key ] = node[ key ].map( toJSON );
		} else if ( node[ key ] && node[ key ].toJSON ) {
			obj[ key ] = node[ key ].toJSON();
		} else {
			obj[ key ] = node[ key ];
		}
	});

	return obj;
}

var Node = function Node ( raw, parent ) {
	raw.parent = parent;
	raw.program = parent.program || parent;
	raw.depth = parent.depth + 1;
	raw.keys = keys[ raw.type ];
	raw.indentation = undefined;

	for ( var i = 0, list = keys[ raw.type ]; i < list.length; i += 1 ) {
		var key = list[i];

			wrap( raw[ key ], raw );
	}

	raw.program.magicString.addSourcemapLocation( raw.start );
	raw.program.magicString.addSourcemapLocation( raw.end );
};

Node.prototype.ancestor = function ancestor ( level ) {
	var node = this;
	while ( level-- ) {
		node = node.parent;
		if ( !node ) return null;
	}

	return node;
};

Node.prototype.contains = function contains ( node ) {
		var this$1 = this;

	while ( node ) {
		if ( node === this$1 ) return true;
		node = node.parent;
	}

	return false;
};

Node.prototype.findLexicalBoundary = function findLexicalBoundary () {
	return this.parent.findLexicalBoundary();
};

Node.prototype.findNearest = function findNearest ( type ) {
	if ( typeof type === 'string' ) type = new RegExp( ("^" + type + "$") );
	if ( type.test( this.type ) ) return this;
	return this.parent.findNearest( type );
};

Node.prototype.findScope = function findScope ( functionScope ) {
	return this.parent.findScope( functionScope );
};

Node.prototype.getIndentation = function getIndentation () {
	return this.parent.getIndentation();
};

Node.prototype.initialise = function initialise ( transforms ) {
	for ( var i = 0, list = this.keys; i < list.length; i += 1 ) {
		var key = list[i];

			var value = this[ key ];

		if ( Array.isArray( value ) ) {
			value.forEach( function ( node ) { return node && node.initialise( transforms ); } );
		} else if ( value && typeof value === 'object' ) {
			value.initialise( transforms );
		}
	}
};

Node.prototype.toJSON = function toJSON$1 () {
	return toJSON( this );
};

Node.prototype.toString = function toString () {
	return this.program.magicString.original.slice( this.start, this.end );
};

Node.prototype.transpile = function transpile ( code, transforms ) {
	for ( var i = 0, list = this.keys; i < list.length; i += 1 ) {
		var key = list[i];

			var value = this[ key ];

		if ( Array.isArray( value ) ) {
			value.forEach( function ( node ) { return node && node.transpile( code, transforms ); } );
		} else if ( value && typeof value === 'object' ) {
			value.transpile( code, transforms );
		}
	}
};

function isArguments ( node ) {
	return node.type === 'Identifier' && node.name === 'arguments';
}

function spread ( code, elements, start, argumentsArrayAlias ) {
	var i = elements.length;
	var firstSpreadIndex = -1;

	while ( i-- ) {
		var element$1 = elements[i];
		if ( element$1 && element$1.type === 'SpreadElement' ) {
			if ( isArguments( element$1.argument ) ) {
				code.overwrite( element$1.argument.start, element$1.argument.end, argumentsArrayAlias );
			}

			firstSpreadIndex = i;
		}
	}

	if ( firstSpreadIndex === -1 ) return false; // false indicates no spread elements

	var element = elements[ firstSpreadIndex ];
	var previousElement = elements[ firstSpreadIndex - 1 ];

	if ( !previousElement ) {
		code.remove( start, element.start );
		code.overwrite( element.end, elements[1].start, '.concat( ' );
	} else {
		code.overwrite( previousElement.end, element.start, ' ].concat( ' );
	}

	for ( i = firstSpreadIndex; i < elements.length; i += 1 ) {
		element = elements[i];

		if ( element ) {
			if ( element.type === 'SpreadElement' ) {
				code.remove( element.start, element.argument.start );
			} else {
				code.insertRight( element.start, '[' );
				code.insertLeft( element.end, ']' );
			}
		}
	}

	return true; // true indicates some spread elements
}

var ArrayExpression = (function (Node) {
	function ArrayExpression () {
		Node.apply(this, arguments);
	}

	if ( Node ) ArrayExpression.__proto__ = Node;
	ArrayExpression.prototype = Object.create( Node && Node.prototype );
	ArrayExpression.prototype.constructor = ArrayExpression;

	ArrayExpression.prototype.initialise = function initialise ( transforms ) {
		var this$1 = this;

		if ( transforms.spreadRest && this.elements.length ) {
			var lexicalBoundary = this.findLexicalBoundary();

			var i = this.elements.length;
			while ( i-- ) {
				var element = this$1.elements[i];
				if ( element && element.type === 'SpreadElement' && isArguments( element.argument ) ) {
					this$1.argumentsArrayAlias = lexicalBoundary.getArgumentsArrayAlias();
				}
			}
		}

		Node.prototype.initialise.call( this, transforms );
	};

	ArrayExpression.prototype.transpile = function transpile ( code, transforms ) {
		if ( transforms.spreadRest ) {
			if ( this.elements.length === 1 ) {
				var element = this.elements[0];

				if ( element && element.type === 'SpreadElement' ) {
					// special case – [ ...arguments ]
					if ( isArguments( element.argument ) ) {
						code.overwrite( this.start, this.end, ("[].concat( " + (this.argumentsArrayAlias) + " )") ); // TODO if this is the only use of argsArray, don't bother concating
					} else {
						code.overwrite( this.start, element.argument.start, '[].concat( ' );
						code.overwrite( element.end, this.end, ' )' );
					}
				}
			}

			else {
				var hasSpreadElements = spread( code, this.elements, this.start, this.argumentsArrayAlias );

				if ( hasSpreadElements ) {
					code.overwrite( this.end - 1, this.end, ')' );
				}
			}
		}

		Node.prototype.transpile.call( this, code, transforms );
	};

	return ArrayExpression;
}(Node));

var ArrowFunctionExpression = (function (Node) {
	function ArrowFunctionExpression () {
		Node.apply(this, arguments);
	}

	if ( Node ) ArrowFunctionExpression.__proto__ = Node;
	ArrowFunctionExpression.prototype = Object.create( Node && Node.prototype );
	ArrowFunctionExpression.prototype.constructor = ArrowFunctionExpression;

	ArrowFunctionExpression.prototype.initialise = function initialise ( transforms ) {
		this.body.createScope();
		Node.prototype.initialise.call( this, transforms );
	};

	ArrowFunctionExpression.prototype.transpile = function transpile ( code, transforms ) {
		if ( transforms.arrow ) {
			// remove arrow
			var charIndex = this.body.start;
			while ( code.original[ charIndex ] !== '=' ) {
				charIndex -= 1;
			}
			code.remove( charIndex, this.body.start );

			// wrap naked parameter
			if ( this.params.length === 1 && this.start === this.params[0].start ) {
				code.insertRight( this.params[0].start, '(' );
				code.insertLeft( this.params[0].end, ')' );
			}

			// add function
			code.insertRight( this.start, 'function ' );
		}

		Node.prototype.transpile.call( this, code, transforms );
	};

	return ArrowFunctionExpression;
}(Node));

function locate ( source, index ) {
	var lines = source.split( '\n' );
	var len = lines.length;

	var lineStart = 0;
	var i;

	for ( i = 0; i < len; i += 1 ) {
		var line = lines[i];
		var lineEnd =  lineStart + line.length + 1; // +1 for newline

		if ( lineEnd > index ) {
			return { line: i + 1, column: index - lineStart, char: i };
		}

		lineStart = lineEnd;
	}

	throw new Error( 'Could not determine location of character' );
}

function pad ( num, len ) {
	var result = String( num );
	return result + repeat( ' ', len - result.length );
}

function repeat ( str, times ) {
	var result = '';
	while ( times-- ) result += str;
	return result;
}

function getSnippet ( source, loc, length ) {
	if ( length === void 0 ) length = 1;

	var first = Math.max( loc.line - 5, 0 );
	var last = loc.line;

	var numDigits = String( last ).length;

	var lines = source.split( '\n' ).slice( first, last );

	var lastLine = lines[ lines.length - 1 ];
	var offset = lastLine.slice( 0, loc.column ).replace( /\t/g, '  ' ).length;

	var snippet = lines
		.map( function ( line, i ) { return ((pad( i + first + 1, numDigits )) + " : " + (line.replace( /\t/g, '  '))); } )
		.join( '\n' );

	snippet += '\n' + repeat( ' ', numDigits + 3 + offset ) + repeat( '^', length );

	return snippet;
}

var CompileError = (function (Error) {
	function CompileError ( node, message ) {
		Error.call(this);

		var source = node.program.magicString.original;
		var loc = locate( source, node.start );

		this.name = 'CompileError';
		this.message = message + " (" + (loc.line) + ":" + (loc.column) + ")";

		this.stack = new Error().stack.replace( new RegExp( (".+new " + (this.name) + ".+\\n"), 'm' ), '' );

		this.loc = loc;
		this.snippet = getSnippet( source, loc, node.end - node.start );
	}

	if ( Error ) CompileError.__proto__ = Error;
	CompileError.prototype = Object.create( Error && Error.prototype );
	CompileError.prototype.constructor = CompileError;

	return CompileError;
}(Error));

var AssignmentExpression = (function (Node) {
	function AssignmentExpression () {
		Node.apply(this, arguments);
	}

	if ( Node ) AssignmentExpression.__proto__ = Node;
	AssignmentExpression.prototype = Object.create( Node && Node.prototype );
	AssignmentExpression.prototype.constructor = AssignmentExpression;

	AssignmentExpression.prototype.initialise = function initialise ( transforms ) {
		if ( this.left.type === 'Identifier' ) {
			var declaration = this.findScope( false ).findDeclaration( this.left.name );
			if ( declaration && declaration.kind === 'const' ) {
				throw new CompileError( this.left, ((this.left.name) + " is read-only") );
			}

			// special case – https://gitlab.com/Rich-Harris/buble/issues/11
			var statement = declaration && declaration.node.ancestor( 3 );
			if ( statement && statement.type === 'ForStatement' && statement.body.contains( this ) ) {
				statement.reassigned[ this.left.name ] = true;
			}
		}

		if ( /Pattern/.test( this.left.type ) ) {
			throw new CompileError( this.left, 'Destructuring assignments are not currently supported. Coming soon!' );
		}

		Node.prototype.initialise.call( this, transforms );
	};

	AssignmentExpression.prototype.transpile = function transpile ( code, transforms ) {
		if ( this.operator === '**=' && transforms.exponentiation ) {
			var scope = this.findScope( false );
			var getAlias = function ( name ) {
				var declaration = scope.findDeclaration( name );
				return declaration ? declaration.name : name;
			};

			// first, the easy part – `**=` -> `=`
			var charIndex = this.left.end;
			while ( code.original[ charIndex ] !== '*' ) charIndex += 1;
			code.remove( charIndex, charIndex + 2 );

			// how we do the next part depends on a number of factors – whether
			// this is a top-level statement, and whether we're updating a
			// simple or complex reference
			var base;

			var left = this.left;
			while ( left.type === 'ParenthesizedExpression' ) left = left.expression;

			if ( left.type === 'Identifier' ) {
				base = getAlias( left.name );
			} else if ( left.type === 'MemberExpression' ) {
				var object;
				var needsObjectVar = false;
				var property;
				var needsPropertyVar = false;

				var statement = this.findNearest( /(?:Statement|Declaration)$/ );
				var i0 = statement.getIndentation();

				if ( left.property.type === 'Identifier' ) {
					property = left.computed ? getAlias( left.property.name ) : left.property.name;
				} else {
					property = scope.createIdentifier( 'property' );
					needsPropertyVar = true;
				}

				if ( left.object.type === 'Identifier' ) {
					object = getAlias( left.object.name );
				} else {
					object = scope.createIdentifier( 'object' );
					needsObjectVar = true;
				}

				if ( left.start === statement.start ) {
					if ( needsObjectVar && needsPropertyVar ) {
						code.insertRight( statement.start, ("var " + object + " = ") );
						code.overwrite( left.object.end, left.property.start, (";\n" + i0 + "var " + property + " = ") );
						code.overwrite( left.property.end, left.end, (";\n" + i0 + object + "[" + property + "]") );
					}

					else if ( needsObjectVar ) {
						code.insertRight( statement.start, ("var " + object + " = ") );
						code.insertLeft( left.object.end, (";\n" + i0) );
						code.insertLeft( left.object.end, object );
					}

					else if ( needsPropertyVar ) {
						code.insertRight( left.property.start, ("var " + property + " = ") );
						code.insertLeft( left.property.end, (";\n" + i0) );
						code.move( left.property.start, left.property.end, this.start );

						code.insertLeft( left.object.end, ("[" + property + "]") );
						code.remove( left.object.end, left.property.start );
						code.remove( left.property.end, left.end );
					}
				}

				else {
					var declarators = [];
					if ( needsObjectVar ) declarators.push( object );
					if ( needsPropertyVar ) declarators.push( property );
					code.insertRight( statement.start, ("var " + (declarators.join( ', ' )) + ";\n" + i0) );

					if ( needsObjectVar && needsPropertyVar ) {
						code.insertRight( left.start, ("( " + object + " = ") );
						code.overwrite( left.object.end, left.property.start, (", " + property + " = ") );
						code.overwrite( left.property.end, left.end, (", " + object + "[" + property + "]") );
					}

					else if ( needsObjectVar ) {
						code.insertRight( left.start, ("( " + object + " = ") );
						code.insertLeft( left.object.end, (", " + object) );
					}

					else if ( needsPropertyVar ) {
						code.insertRight( left.property.start, ("( " + property + " = ") );
						code.insertLeft( left.property.end, ", " );
						code.move( left.property.start, left.property.end, left.start );

						code.overwrite( left.object.end, left.property.start, ("[" + property + "]") );
						code.remove( left.property.end, left.end );
					}

					code.insertLeft( this.end, " )" );
				}

				base = object + ( left.computed || needsPropertyVar ? ("[" + property + "]") : ("." + property) );
			}

			code.insertRight( this.right.start, ("Math.pow( " + base + ", ") );
			code.insertLeft( this.right.end, " )" );
		}

		Node.prototype.transpile.call( this, code, transforms );
	};

	return AssignmentExpression;
}(Node));

var BinaryExpression = (function (Node) {
	function BinaryExpression () {
		Node.apply(this, arguments);
	}

	if ( Node ) BinaryExpression.__proto__ = Node;
	BinaryExpression.prototype = Object.create( Node && Node.prototype );
	BinaryExpression.prototype.constructor = BinaryExpression;

	BinaryExpression.prototype.transpile = function transpile ( code, transforms ) {
		if ( this.operator === '**' && transforms.exponentiation ) {
			code.insertRight( this.start, "Math.pow( " );
			code.overwrite( this.left.end, this.right.start, ", " );
			code.insertLeft( this.end, " )" );
		}
		Node.prototype.transpile.call( this, code, transforms );
	};

	return BinaryExpression;
}(Node));

var BreakStatement = (function (Node) {
	function BreakStatement () {
		Node.apply(this, arguments);
	}

	if ( Node ) BreakStatement.__proto__ = Node;
	BreakStatement.prototype = Object.create( Node && Node.prototype );
	BreakStatement.prototype.constructor = BreakStatement;

	BreakStatement.prototype.initialise = function initialise ( transforms ) {
		var loop = this.findNearest( /(?:For(?:In)?|While)Statement/ );
		var switchCase = this.findNearest( 'SwitchCase' );

		if ( loop && ( !switchCase || loop.depth > switchCase.depth ) ) {
			loop.canBreak = true;
			this.loop = loop;
		}
	};

	BreakStatement.prototype.transpile = function transpile ( code, transforms ) {
		if ( this.loop && this.loop.shouldRewriteAsFunction ) {
			if ( this.label ) throw new CompileError( this, 'Labels are not currently supported in a loop with locally-scoped variables' );
			code.overwrite( this.start, this.start + 5, "return 'break'" );
		}
	};

	return BreakStatement;
}(Node));

var CallExpression = (function (Node) {
	function CallExpression () {
		Node.apply(this, arguments);
	}

	if ( Node ) CallExpression.__proto__ = Node;
	CallExpression.prototype = Object.create( Node && Node.prototype );
	CallExpression.prototype.constructor = CallExpression;

	CallExpression.prototype.initialise = function initialise ( transforms ) {
		var this$1 = this;

		if ( transforms.spreadRest && this.arguments.length > 1 ) {
			var lexicalBoundary = this.findLexicalBoundary();

			var i = this.arguments.length;
			while ( i-- ) {
				var arg = this$1.arguments[i];
				if ( arg.type === 'SpreadElement' && isArguments( arg.argument ) ) {
					this$1.argumentsArrayAlias = lexicalBoundary.getArgumentsArrayAlias();
				}
			}
		}

		Node.prototype.initialise.call( this, transforms );
	};

	CallExpression.prototype.transpile = function transpile ( code, transforms ) {
		if ( transforms.spreadRest && this.arguments.length ) {
			var hasSpreadElements = false;
			var context;

			var firstArgument = this.arguments[0];

			if ( this.arguments.length === 1 ) {
				if ( firstArgument.type === 'SpreadElement' ) {
					code.remove( firstArgument.start, firstArgument.argument.start );
					hasSpreadElements = true;
				}
			} else {
				hasSpreadElements = spread( code, this.arguments, firstArgument.start, this.argumentsArrayAlias );
			}

			if ( hasSpreadElements ) {
				if ( this.callee.type === 'MemberExpression' ) {
					if ( this.callee.object.type === 'Identifier' ) {
						context = this.callee.object.name;
					} else {
						var statement = this.callee.object;
						var i0 = statement.getIndentation();
						context = this.findScope( true ).createIdentifier( 'ref' );
						code.insertRight( statement.start, ("var " + context + " = ") );
						code.insertLeft( statement.end, (";\n" + i0 + context) );
					}
				} else {
					context = 'void 0';
				}

				if ( this.arguments.length === 1 ) {
					code.insertRight( firstArgument.start, (context + ", ") );
					code.insertLeft( this.callee.end, '.apply' );
				} else {
					if ( firstArgument.type === 'SpreadElement' ) {
						code.insertRight( firstArgument.start, (context + ", ") );
					} else {
						code.insertRight( firstArgument.start, (context + ", [ ") );
					}

					code.insertLeft( this.arguments[ this.arguments.length - 1 ].end, ' )' );
					code.insertLeft( this.callee.end, '.apply' );
				}
			}
		}

		Node.prototype.transpile.call( this, code, transforms );
	};

	return CallExpression;
}(Node));

function findIndex ( array, fn ) {
	for ( var i = 0; i < array.length; i += 1 ) {
		if ( fn( array[i], i ) ) return i;
	}

	return -1;
}

// TODO this code is pretty wild, tidy it up
var ClassBody = (function (Node) {
	function ClassBody () {
		Node.apply(this, arguments);
	}

	if ( Node ) ClassBody.__proto__ = Node;
	ClassBody.prototype = Object.create( Node && Node.prototype );
	ClassBody.prototype.constructor = ClassBody;

	ClassBody.prototype.transpile = function transpile ( code, transforms, inFunctionExpression, superName ) {
		var this$1 = this;

		if ( transforms.classes ) {
			var name = this.parent.name;

			var indentStr = code.getIndentString();
			var i0 = this.getIndentation() + ( inFunctionExpression ? indentStr : '' );
			var i1 = i0 + indentStr;

			var constructorIndex = findIndex( this.body, function ( node ) { return node.kind === 'constructor'; } );
			var constructor = this.body[ constructorIndex ];

			var introBlock = '';
			var outroBlock = '';

			if ( this.body.length ) {
				code.remove( this.start, this.body[0].start );
				code.remove( this.body[ this.body.length - 1 ].end, this.end );
			} else {
				code.remove( this.start, this.end );
			}

			if ( constructor ) {
				constructor.value.body.isConstructorBody = true;

				var previousMethod = this.body[ constructorIndex - 1 ];
				var nextMethod = this.body[ constructorIndex + 1 ];

				// ensure constructor is first
				if ( constructorIndex > 0 ) {
					code.remove( previousMethod.end, constructor.start );
					code.move( constructor.start, nextMethod ? nextMethod.start : this.end - 1, this.body[0].start );
				}

				if ( !inFunctionExpression ) code.insertLeft( constructor.end, ';' );
			}

			if ( this.parent.superClass ) {
				var inheritanceBlock = "if ( " + superName + " ) " + name + ".__proto__ = " + superName + ";\n" + i0 + name + ".prototype = Object.create( " + superName + " && " + superName + ".prototype );\n" + i0 + name + ".prototype.constructor = " + name + ";";

				if ( constructor ) {
					introBlock += "\n\n" + i0 + inheritanceBlock;
				} else {
					var fn = "function " + name + " () {" + ( superName ?
						("\n" + i1 + superName + ".apply(this, arguments);\n" + i0 + "}") :
						"}" ) + ( inFunctionExpression ? '' : ';' ) + ( this.body.length ? ("\n\n" + i0) : '' );

					inheritanceBlock = fn + inheritanceBlock;
					introBlock += inheritanceBlock + "\n\n" + i0;
				}
			} else if ( !constructor ) {
				var fn$1 = "function " + name + " () {}";
				if ( this.parent.type === 'ClassDeclaration' ) fn$1 += ';';
				if ( this.body.length ) fn$1 += "\n\n" + i0;

				introBlock += fn$1;
			}

			var scope = this.findScope( false );

			var prototypeGettersAndSetters = [];
			var staticGettersAndSetters = [];
			var prototypeAccessors;
			var staticAccessors;

			this.body.forEach( function ( method, i ) {
				if ( method.kind === 'constructor' ) {
					code.overwrite( method.key.start, method.key.end, ("function " + name) );
					return;
				}

				if ( method.static ) code.remove( method.start, method.start + 7 );

				var isAccessor = method.kind !== 'method';
				var lhs;

				if ( isAccessor ) {
					code.remove( method.start, method.key.end );

					if ( method.static ) {
						if ( !~staticGettersAndSetters.indexOf( method.key.name ) ) staticGettersAndSetters.push( method.key.name );
						if ( !staticAccessors ) staticAccessors = scope.createIdentifier( 'staticAccessors' );

						lhs = staticAccessors + "." + (method.key.name) + "." + (method.kind);
					} else {
						if ( !~prototypeGettersAndSetters.indexOf( method.key.name ) ) prototypeGettersAndSetters.push( method.key.name );
						if ( !prototypeAccessors ) prototypeAccessors = scope.createIdentifier( 'prototypeAccessors' );

						lhs = prototypeAccessors + "." + (method.key.name) + "." + (method.kind);
					}
				} else {
					lhs = method.static ?
						(name + "." + (method.key.name)) :
						(name + ".prototype." + (method.key.name));
				}

				var insertNewlines = ( constructorIndex > 0 && i === constructorIndex + 1 ) ||
				                       ( i === 0 && constructorIndex === this$1.body.length - 1 );

				if ( insertNewlines ) lhs = "\n\n" + i0 + lhs;

				code.insertRight( method.start, lhs + " = function" + ( method.value.generator ? '*' : '' ) + ( isAccessor ? '' : ' ' ) );
				code.insertLeft( method.end, ';' );

				if ( method.value.generator ) code.remove( method.start, method.key.start );

				// prevent function name shadowing an existing declaration
				if ( scope.contains( method.key.name ) ) {
					code.overwrite( method.key.start, method.key.end, scope.createIdentifier( method.key.name ), true );
				}
			});

			if ( prototypeGettersAndSetters.length || staticGettersAndSetters.length ) {
				var intro = [];
				var outro = [];

				if ( prototypeGettersAndSetters.length ) {
					intro.push( ("var " + prototypeAccessors + " = { " + (prototypeGettersAndSetters.map( function ( name ) { return (name + ": {}"); } ).join( ',' )) + " };") );
					outro.push( ("Object.defineProperties( " + name + ".prototype, " + prototypeAccessors + " );") );
				}

				if ( staticGettersAndSetters.length ) {
					intro.push( ("var " + staticAccessors + " = { " + (staticGettersAndSetters.map( function ( name ) { return (name + ": {}"); } ).join( ',' )) + " };") );
					outro.push( ("Object.defineProperties( " + name + ", " + staticAccessors + " );") );
				}

				if ( constructor ) introBlock += "\n\n" + i0;
				introBlock += intro.join( ("\n" + i0) );
				if ( !constructor ) introBlock += "\n\n" + i0;

				outroBlock += "\n\n" + i0 + outro.join( ("\n" + i0) );
			}

			if ( constructor ) {
				code.insertLeft( constructor.end, introBlock );
			} else {
				code.insertRight( this.start, introBlock );
			}

			code.insertLeft( this.end, outroBlock );
		}

		Node.prototype.transpile.call( this, code, transforms );
	};

	return ClassBody;
}(Node));

// TODO this function is slightly flawed – it works on the original string,
// not its current edited state.
// That's not a problem for the way that it's currently used, but it could
// be in future...
function deindent ( node, code ) {
	var start = node.start;
	var end = node.end;

	var indentStr = code.getIndentString();
	var pattern = new RegExp( indentStr + '\\S', 'g' );

	if ( code.original.slice( start - indentStr.length, start ) === indentStr ) {
		code.remove( start - indentStr.length, start );
	}

	var slice = code.original.slice( start, end );
	var match;
	while ( match = pattern.exec( slice ) ) {
		if ( !node.program.indentExclusions[ match.index ] ) code.remove( start + match.index, start + match.index + indentStr.length );
	}
}

var ClassDeclaration = (function (Node) {
	function ClassDeclaration () {
		Node.apply(this, arguments);
	}

	if ( Node ) ClassDeclaration.__proto__ = Node;
	ClassDeclaration.prototype = Object.create( Node && Node.prototype );
	ClassDeclaration.prototype.constructor = ClassDeclaration;

	ClassDeclaration.prototype.initialise = function initialise ( transforms ) {
		this.name = this.id.name;
		this.findScope( true ).addDeclaration( this.id, 'class' );

		Node.prototype.initialise.call( this, transforms );
	};

	ClassDeclaration.prototype.transpile = function transpile ( code, transforms ) {
		if ( transforms.classes ) {
			if ( !this.superClass ) deindent( this.body, code );

			var superName = this.superClass && ( this.superClass.name || 'superclass' );

			var i0 = this.getIndentation();
			var i1 = i0 + code.getIndentString();

			// if this is an export default statement, we have to move the export to
			// after the declaration, because `export default var Foo = ...` is illegal
			var syntheticDefaultExport = this.parent.type === 'ExportDefaultDeclaration' ?
				("\n\n" + i0 + "export default " + (this.id.name) + ";") :
				'';

			if ( syntheticDefaultExport ) code.remove( this.parent.start, this.start );

			code.overwrite( this.start, this.id.start, 'var ' );

			if ( this.superClass ) {
				if ( this.superClass.end === this.body.start ) {
					code.remove( this.id.end, this.superClass.start );
					code.insertLeft( this.id.end, (" = (function (" + superName + ") {\n" + i1) );
				} else {
					code.overwrite( this.id.end, this.superClass.start, ' = ' );
					code.overwrite( this.superClass.end, this.body.start, ("(function (" + superName + ") {\n" + i1) );
				}
			} else {
				if ( this.id.end === this.body.start ) {
					code.insertLeft( this.id.end, ' = ' );
				} else {
					code.overwrite( this.id.end, this.body.start, ' = ' );
				}
			}

			this.body.transpile( code, transforms, !!this.superClass, superName );

			if ( this.superClass ) {
				code.insertLeft( this.end, ("\n\n" + i1 + "return " + (this.name) + ";\n" + i0 + "}(") );
				code.move( this.superClass.start, this.superClass.end, this.end );
				code.insertRight( this.end, ("));" + syntheticDefaultExport) );
			} else if ( syntheticDefaultExport ) {
				code.insertRight( this.end, syntheticDefaultExport );
			}
		}

		else {
			this.body.transpile( code, transforms, false, null );
		}
	};

	return ClassDeclaration;
}(Node));

var ClassExpression = (function (Node) {
	function ClassExpression () {
		Node.apply(this, arguments);
	}

	if ( Node ) ClassExpression.__proto__ = Node;
	ClassExpression.prototype = Object.create( Node && Node.prototype );
	ClassExpression.prototype.constructor = ClassExpression;

	ClassExpression.prototype.initialise = function initialise ( transforms ) {
		this.name = this.id ? this.id.name :
		            this.parent.type === 'VariableDeclarator' ? this.parent.id.name :
		            this.parent.type === 'AssignmentExpression' ? this.parent.left.name :
		            this.findScope( true ).createIdentifier( 'anonymous' );

		Node.prototype.initialise.call( this, transforms );
	};

	ClassExpression.prototype.transpile = function transpile ( code, transforms ) {
		if ( transforms.classes ) {
			var superName = this.superClass && ( this.superClass.name || 'superclass' );

			var i0 = this.getIndentation();
			var i1 = i0 + code.getIndentString();

			if ( this.superClass ) {
				code.remove( this.start, this.superClass.start );
				code.remove( this.superClass.end, this.body.start );
				code.insertLeft( this.start, ("(function (" + superName + ") {\n" + i1) );
			} else {
				code.overwrite( this.start, this.body.start, ("(function () {\n" + i1) );
			}

			this.body.transpile( code, transforms, true, superName );

			var outro = "\n\n" + i1 + "return " + (this.name) + ";\n" + i0 + "}(";

			if ( this.superClass ) {
				code.insertLeft( this.end, outro );
				code.move( this.superClass.start, this.superClass.end, this.end );
				code.insertRight( this.end, '))' );
			} else {
				code.insertLeft( this.end, ("\n\n" + i1 + "return " + (this.name) + ";\n" + i0 + "}())") );
			}
		}

		else {
			this.body.transpile( code, transforms, false );
		}
	};

	return ClassExpression;
}(Node));

var ContinueStatement = (function (Node) {
	function ContinueStatement () {
		Node.apply(this, arguments);
	}

	if ( Node ) ContinueStatement.__proto__ = Node;
	ContinueStatement.prototype = Object.create( Node && Node.prototype );
	ContinueStatement.prototype.constructor = ContinueStatement;

	ContinueStatement.prototype.transpile = function transpile ( code, transforms ) {
		var loop = this.findNearest( /(?:For(?:In|Of)?|While)Statement/ );
		if ( loop.shouldRewriteAsFunction ) {
			if ( this.label ) throw new CompileError( this, 'Labels are not currently supported in a loop with locally-scoped variables' );
			code.overwrite( this.start, this.start + 8, 'return' );
		}
	};

	return ContinueStatement;
}(Node));

var ExportDefaultDeclaration = (function (Node) {
	function ExportDefaultDeclaration () {
		Node.apply(this, arguments);
	}

	if ( Node ) ExportDefaultDeclaration.__proto__ = Node;
	ExportDefaultDeclaration.prototype = Object.create( Node && Node.prototype );
	ExportDefaultDeclaration.prototype.constructor = ExportDefaultDeclaration;

	ExportDefaultDeclaration.prototype.initialise = function initialise ( transforms ) {
		if ( transforms.moduleExport ) throw new CompileError( this, 'export is not supported' );
		Node.prototype.initialise.call( this, transforms );
	};

	return ExportDefaultDeclaration;
}(Node));

var ExportNamedDeclaration = (function (Node) {
	function ExportNamedDeclaration () {
		Node.apply(this, arguments);
	}

	if ( Node ) ExportNamedDeclaration.__proto__ = Node;
	ExportNamedDeclaration.prototype = Object.create( Node && Node.prototype );
	ExportNamedDeclaration.prototype.constructor = ExportNamedDeclaration;

	ExportNamedDeclaration.prototype.initialise = function initialise ( transforms ) {
		if ( transforms.moduleExport ) throw new CompileError( this, 'export is not supported' );
		Node.prototype.initialise.call( this, transforms );
	};

	return ExportNamedDeclaration;
}(Node));

function extractNames ( node ) {
	var names = [];
	extractors[ node.type ]( names, node );
	return names;
}

var extractors = {
	Identifier: function Identifier ( names, node ) {
		names.push( node );
	},

	ObjectPattern: function ObjectPattern ( names, node ) {
		for ( var i = 0, list = node.properties; i < list.length; i += 1 ) {
			var prop = list[i];

			extractors[ prop.value.type ]( names, prop.value );
		}
	},

	ArrayPattern: function ArrayPattern ( names, node ) {
		for ( var i = 0, list = node.elements; i < list.length; i += 1 )  {
			var element = list[i];

			if ( element ) extractors[ element.type ]( names, element );
		}
	},

	RestElement: function RestElement ( names, node ) {
		extractors[ node.argument.type ]( names, node.argument );
	},

	AssignmentPattern: function AssignmentPattern ( names, node ) {
		extractors[ node.left.type ]( names, node.left );
	}
};

var LoopStatement = (function (Node) {
	function LoopStatement () {
		Node.apply(this, arguments);
	}

	if ( Node ) LoopStatement.__proto__ = Node;
	LoopStatement.prototype = Object.create( Node && Node.prototype );
	LoopStatement.prototype.constructor = LoopStatement;

	LoopStatement.prototype.findScope = function findScope ( functionScope ) {
		return functionScope || !this.createdScope ? this.parent.findScope( functionScope ) : this.body.scope;
	};

	LoopStatement.prototype.initialise = function initialise ( transforms ) {
		var this$1 = this;

		this.body.createScope();
		this.createdScope = true;

		// this is populated as and when reassignments occur
		this.reassigned = Object.create( null );
		this.aliases = Object.create( null );

		Node.prototype.initialise.call( this, transforms );

		if ( transforms.letConst ) {
			// see if any block-scoped declarations are referenced
			// inside function expressions
			var names = Object.keys( this.body.scope.declarations );

			var i = names.length;
			while ( i-- ) {
				var name = names[i];
				var declaration = this$1.body.scope.declarations[ name ];

				var j = declaration.instances.length;
				while ( j-- ) {
					var instance = declaration.instances[j];
					var nearestFunctionExpression = instance.findNearest( /Function/ );

					if ( nearestFunctionExpression && nearestFunctionExpression.depth > this$1.depth ) {
						this$1.shouldRewriteAsFunction = true;
						break;
					}
				}

				if ( this$1.shouldRewriteAsFunction ) break;
			}
		}
	};

	LoopStatement.prototype.transpile = function transpile ( code, transforms ) {
		if ( this.shouldRewriteAsFunction ) {
			var i0 = this.getIndentation();
			var i1 = i0 + code.getIndentString();

			var argString = this.args ? (" " + (this.args.join( ', ' )) + " ") : '';
			var paramString = this.params ? (" " + (this.params.join( ', ' )) + " ") : '';

			var functionScope = this.findScope( true );
			var loop = functionScope.createIdentifier( 'loop' );

			var before = "var " + loop + " = function (" + paramString + ") " + ( this.body.synthetic ? ("{\n" + i0 + (code.getIndentString())) : '' );
			var after = ( this.body.synthetic ? ("\n" + i0 + "}") : '' ) + ";\n\n" + i0;

			code.insertRight( this.body.start, before );
			code.insertLeft( this.body.end, after );
			code.move( this.start, this.body.start, this.body.end );

			if ( this.canBreak || this.canReturn ) {
				var returned = functionScope.createIdentifier( 'returned' );

				var insert = "{\n" + i1 + "var " + returned + " = " + loop + "(" + argString + ");\n";
				if ( this.canBreak ) insert += "\n" + i1 + "if ( " + returned + " === 'break' ) break;";
				if ( this.canReturn ) insert += "\n" + i1 + "if ( " + returned + " ) return returned.v;";
				insert += "\n" + i0 + "}";

				code.insertRight( this.body.end, insert );
			} else {
				var callExpression = loop + "(" + argString + ");";

				if ( this.type === 'DoWhileStatement' ) {
					code.overwrite( this.start, this.body.start, ("do {\n" + i1 + callExpression + "\n" + i0 + "}") );
				} else {
					code.insertRight( this.body.end, callExpression );
				}
			}
		}

		Node.prototype.transpile.call( this, code, transforms );
	};

	return LoopStatement;
}(Node));

var ForStatement = (function (LoopStatement) {
	function ForStatement () {
		LoopStatement.apply(this, arguments);
	}

	if ( LoopStatement ) ForStatement.__proto__ = LoopStatement;
	ForStatement.prototype = Object.create( LoopStatement && LoopStatement.prototype );
	ForStatement.prototype.constructor = ForStatement;

	ForStatement.prototype.findScope = function findScope ( functionScope ) {
		return functionScope || !this.createdScope ? this.parent.findScope( functionScope ) : this.body.scope;
	};

	ForStatement.prototype.transpile = function transpile ( code, transforms ) {
		var this$1 = this;

		var i1 = this.getIndentation() + code.getIndentString();

		if ( this.shouldRewriteAsFunction ) {
			// which variables are declared in the init statement?
			var names = this.init.type === 'VariableDeclaration' ?
				[].concat.apply( [], this.init.declarations.map( function ( declarator ) { return extractNames( declarator.id ); } ) ) :
				[];

			var aliases = this.aliases;

			this.args = names.map( function ( name ) { return name in this$1.aliases ? this$1.aliases[ name ].outer : name; } );
			this.params = names.map( function ( name ) { return name in this$1.aliases ? this$1.aliases[ name ].inner : name; } );

			var updates = Object.keys( this.reassigned )
				.map( function ( name ) { return ((aliases[ name ].outer) + " = " + (aliases[ name ].inner) + ";"); } );

			if ( updates.length ) {
				if ( this.body.synthetic ) {
					code.insertLeft( this.body.body[0].end, ("; " + (updates.join(" "))) );
				} else {
					var lastStatement = this.body.body[ this.body.body.length - 1 ];
					code.insertLeft( lastStatement.end, ("\n\n" + i1 + (updates.join(("\n" + i1)))) );
				}
			}
		}

		LoopStatement.prototype.transpile.call( this, code, transforms );
	};

	return ForStatement;
}(LoopStatement));

var ForInStatement = (function (LoopStatement) {
	function ForInStatement () {
		LoopStatement.apply(this, arguments);
	}

	if ( LoopStatement ) ForInStatement.__proto__ = LoopStatement;
	ForInStatement.prototype = Object.create( LoopStatement && LoopStatement.prototype );
	ForInStatement.prototype.constructor = ForInStatement;

	ForInStatement.prototype.findScope = function findScope ( functionScope ) {
		return functionScope || !this.createdScope ? this.parent.findScope( functionScope ) : this.body.scope;
	};

	ForInStatement.prototype.transpile = function transpile ( code, transforms ) {
		var this$1 = this;

		if ( this.shouldRewriteAsFunction ) {
			// which variables are declared in the init statement?
			var names = this.left.type === 'VariableDeclaration' ?
				[].concat.apply( [], this.left.declarations.map( function ( declarator ) { return extractNames( declarator.id ); } ) ) :
				[];

			this.args = names.map( function ( name ) { return name in this$1.aliases ? this$1.aliases[ name ].outer : name; } );
			this.params = names.map( function ( name ) { return name in this$1.aliases ? this$1.aliases[ name ].inner : name; } );
		}

		LoopStatement.prototype.transpile.call( this, code, transforms );
	};

	return ForInStatement;
}(LoopStatement));

var ForOfStatement = (function (LoopStatement) {
	function ForOfStatement () {
		LoopStatement.apply(this, arguments);
	}

	if ( LoopStatement ) ForOfStatement.__proto__ = LoopStatement;
	ForOfStatement.prototype = Object.create( LoopStatement && LoopStatement.prototype );
	ForOfStatement.prototype.constructor = ForOfStatement;

	ForOfStatement.prototype.initialise = function initialise ( transforms ) {
		if ( transforms.forOf && !transforms.dangerousForOf ) throw new CompileError( this, 'for...of statements are not supported. Use `transforms: { forOf: false }` to skip transformation and disable this error, or `transforms: { dangerousForOf: true }` if you know what you\'re doing' );
		LoopStatement.prototype.initialise.call( this, transforms );
	};

	ForOfStatement.prototype.transpile = function transpile ( code, transforms ) {
		if ( !transforms.dangerousForOf ) {
			LoopStatement.prototype.transpile.call( this, code, transforms );
			return;
		}

		var scope = this.findScope( true );
		var i0 = this.getIndentation();
		var i1 = i0 + code.getIndentString();

		var key = scope.createIdentifier( 'i' );
		var list = scope.createIdentifier( 'list' );

		if ( this.body.synthetic ) {
			code.insertRight( this.left.start, ("{\n" + i1) );
			code.insertLeft( this.body.body[0].end, ("\n" + i0 + "}") );
		}

		var bodyStart = this.body.body[0].start;

		code.remove( this.left.end, this.right.start );
		code.move( this.left.start, this.left.end, bodyStart );
		code.insertLeft( this.left.end, (" = " + list + "[" + key + "];\n\n" + i1) );

		code.insertRight( this.right.start, ("var " + key + " = 0, " + list + " = ") );
		code.insertLeft( this.right.end, ("; " + key + " < " + list + ".length; " + key + " += 1") );

		LoopStatement.prototype.transpile.call( this, code, transforms );
	};

	return ForOfStatement;
}(LoopStatement));

var FunctionDeclaration = (function (Node) {
	function FunctionDeclaration () {
		Node.apply(this, arguments);
	}

	if ( Node ) FunctionDeclaration.__proto__ = Node;
	FunctionDeclaration.prototype = Object.create( Node && Node.prototype );
	FunctionDeclaration.prototype.constructor = FunctionDeclaration;

	FunctionDeclaration.prototype.initialise = function initialise ( transforms ) {
		if ( this.generator && transforms.generator ) {
			throw new CompileError( this, 'Generators are not supported' );
		}

		this.body.createScope();

		this.findScope( true ).addDeclaration( this.id, 'function' );
		Node.prototype.initialise.call( this, transforms );
	};

	return FunctionDeclaration;
}(Node));

var FunctionExpression = (function (Node) {
	function FunctionExpression () {
		Node.apply(this, arguments);
	}

	if ( Node ) FunctionExpression.__proto__ = Node;
	FunctionExpression.prototype = Object.create( Node && Node.prototype );
	FunctionExpression.prototype.constructor = FunctionExpression;

	FunctionExpression.prototype.initialise = function initialise ( transforms ) {
		if ( this.generator && transforms.generator ) {
			throw new CompileError( this, 'Generators are not supported' );
		}

		this.body.createScope();

		if ( this.id ) {
			// function expression IDs belong to the child scope...
			this.body.scope.addDeclaration( this.id, 'function' );
		}

		Node.prototype.initialise.call( this, transforms );
	};

	return FunctionExpression;
}(Node));

function isReference ( node, parent ) {
	if ( node.type === 'MemberExpression' ) {
		return !node.computed && isReference( node.object, node );
	}

	if ( node.type === 'Identifier' ) {
		// the only time we could have an identifier node without a parent is
		// if it's the entire body of a function without a block statement –
		// i.e. an arrow function expression like `a => a`
		if ( !parent ) return true;

		if ( /(Function|Class)Expression/.test( parent.type ) ) return false;

		if ( parent.type === 'VariableDeclarator' ) return node === parent.init;

		// TODO is this right?
		if ( parent.type === 'MemberExpression' || parent.type === 'MethodDefinition' ) {
			return parent.computed || node === parent.object;
		}

		if ( parent.type === 'ArrayPattern' ) return false;

		// disregard the `bar` in `{ bar: foo }`, but keep it in `{ [bar]: foo }`
		if ( parent.type === 'Property' ) {
			if ( parent.parent.type === 'ObjectPattern' ) return false;
			return parent.computed || node === parent.value;
		}

		// disregard the `bar` in `class Foo { bar () {...} }`
		if ( parent.type === 'MethodDefinition' ) return false;

		// disregard the `bar` in `export { foo as bar }`
		if ( parent.type === 'ExportSpecifier' && node !== parent.local ) return false;

		return true;
	}
}

var Identifier = (function (Node) {
	function Identifier () {
		Node.apply(this, arguments);
	}

	if ( Node ) Identifier.__proto__ = Node;
	Identifier.prototype = Object.create( Node && Node.prototype );
	Identifier.prototype.constructor = Identifier;

	Identifier.prototype.findScope = function findScope ( functionScope ) {
		if ( this.parent.params && ~this.parent.params.indexOf( this ) ) {
			return this.parent.body.scope;
		}

		if ( this.parent.type === 'FunctionExpression' && this === this.parent.id ) {
			return this.parent.body.scope;
		}

		return this.parent.findScope( functionScope	);
	};

	Identifier.prototype.initialise = function initialise ( transforms ) {
		if ( transforms.arrow && isReference( this, this.parent ) ) {
			if ( this.name === 'arguments' && !this.findScope( false ).contains( this.name ) ) {
				var lexicalBoundary = this.findLexicalBoundary();
				var arrowFunction = this.findNearest( 'ArrowFunctionExpression' );
				var loop = this.findNearest( /(?:For(?:In|Of)?|While)Statement/ );

				if ( arrowFunction && arrowFunction.depth > lexicalBoundary.depth ) {
					this.alias = lexicalBoundary.getArgumentsAlias();
				}

				if ( loop && loop.body.contains( this ) && loop.depth > lexicalBoundary.depth ) {
					this.alias = lexicalBoundary.getArgumentsAlias();
				}
			}

			this.findScope( false ).addReference( this );
		}
	};

	Identifier.prototype.transpile = function transpile ( code, transforms ) {
		if ( this.alias ) {
			code.overwrite( this.start, this.end, this.alias, true );
		}
	};

	return Identifier;
}(Node));

var ImportDeclaration = (function (Node) {
	function ImportDeclaration () {
		Node.apply(this, arguments);
	}

	if ( Node ) ImportDeclaration.__proto__ = Node;
	ImportDeclaration.prototype = Object.create( Node && Node.prototype );
	ImportDeclaration.prototype.constructor = ImportDeclaration;

	ImportDeclaration.prototype.initialise = function initialise ( transforms ) {
		if ( transforms.moduleImport ) throw new CompileError( this, 'import is not supported' );
		Node.prototype.initialise.call( this, transforms );
	};

	return ImportDeclaration;
}(Node));

var ImportDefaultSpecifier = (function (Node) {
	function ImportDefaultSpecifier () {
		Node.apply(this, arguments);
	}

	if ( Node ) ImportDefaultSpecifier.__proto__ = Node;
	ImportDefaultSpecifier.prototype = Object.create( Node && Node.prototype );
	ImportDefaultSpecifier.prototype.constructor = ImportDefaultSpecifier;

	ImportDefaultSpecifier.prototype.initialise = function initialise ( transforms ) {
		this.findScope( true ).addDeclaration( this.local, 'import' );
		Node.prototype.initialise.call( this, transforms );
	};

	return ImportDefaultSpecifier;
}(Node));

var ImportSpecifier = (function (Node) {
	function ImportSpecifier () {
		Node.apply(this, arguments);
	}

	if ( Node ) ImportSpecifier.__proto__ = Node;
	ImportSpecifier.prototype = Object.create( Node && Node.prototype );
	ImportSpecifier.prototype.constructor = ImportSpecifier;

	ImportSpecifier.prototype.initialise = function initialise ( transforms ) {
		this.findScope( true ).addDeclaration( this.local, 'import' );
		Node.prototype.initialise.call( this, transforms );
	};

	return ImportSpecifier;
}(Node));

var IS_DATA_ATTRIBUTE = /-/;

var JSXAttribute = (function (Node) {
	function JSXAttribute () {
		Node.apply(this, arguments);
	}

	if ( Node ) JSXAttribute.__proto__ = Node;
	JSXAttribute.prototype = Object.create( Node && Node.prototype );
	JSXAttribute.prototype.constructor = JSXAttribute;

	JSXAttribute.prototype.transpile = function transpile ( code, transforms ) {
		if ( this.value ) {
			code.overwrite( this.name.end, this.value.start, ': ' );
		} else {
			// tag without value
			code.overwrite( this.name.start, this.name.end, ((this.name.name) + ": true"))
		}

		if ( IS_DATA_ATTRIBUTE.test( this.name.name ) ) {
			code.overwrite( this.name.start, this.name.end, ("'" + (this.name.name) + "'") );
		}

		Node.prototype.transpile.call( this, code, transforms );
	};

	return JSXAttribute;
}(Node));

function containsNewLine ( node ) {
	return node.type === 'Literal' && !/\S/.test( node.value ) && /\n/.test( node.value );
}

var JSXClosingElement = (function (Node) {
	function JSXClosingElement () {
		Node.apply(this, arguments);
	}

	if ( Node ) JSXClosingElement.__proto__ = Node;
	JSXClosingElement.prototype = Object.create( Node && Node.prototype );
	JSXClosingElement.prototype.constructor = JSXClosingElement;

	JSXClosingElement.prototype.transpile = function transpile ( code, transforms ) {
		var spaceBeforeParen = true;

		var lastChild = this.parent.children[ this.parent.children.length - 1 ];

		// omit space before closing paren if
		//   a) this is on a separate line, or
		//   b) there are no children but there are attributes
		if ( ( lastChild && containsNewLine( lastChild ) ) || ( this.parent.openingElement.attributes.length ) ) {
			spaceBeforeParen = false;
		}

		code.overwrite( this.start, this.end, spaceBeforeParen ? ' )' : ')' );
	};

	return JSXClosingElement;
}(Node));

function normalise ( str, removeTrailingWhitespace ) {
	str = str
		.replace( /^\n\r?\s+/, '' )       // remove leading newline + space
		.replace( /\s*\n\r?\s*/gm, ' ' ); // replace newlines with spaces

	if ( removeTrailingWhitespace ) {
		str = str.replace( /\s+$/, '' );
	}

	// TODO prefer single quotes?
	return JSON.stringify( str );
}

var JSXElement = (function (Node) {
	function JSXElement () {
		Node.apply(this, arguments);
	}

	if ( Node ) JSXElement.__proto__ = Node;
	JSXElement.prototype = Object.create( Node && Node.prototype );
	JSXElement.prototype.constructor = JSXElement;

	JSXElement.prototype.transpile = function transpile ( code, transforms ) {
		Node.prototype.transpile.call( this, code, transforms );

		var children = this.children.filter( function ( child ) {
			return child.type === 'JSXElement' || /\S/.test( child.value );
		});

		if ( children.length ) {
			var c = this.openingElement.end;

			var i;
			for ( i = 0; i < children.length; i += 1 ) {
				var child = children[i];

				var tail = code.original[ c ] === '\n' && child.type !== 'Literal' ? '' : ' ';
				code.insertLeft( c, ("," + tail) );

				if ( child.type === 'Literal' ) {
					var str = normalise( child.value, i === children.length - 1 );
					code.overwrite( child.start, child.end, str );
				}

				c = child.end;
			}
		}
	};

	return JSXElement;
}(Node));

var JSXExpressionContainer = (function (Node) {
	function JSXExpressionContainer () {
		Node.apply(this, arguments);
	}

	if ( Node ) JSXExpressionContainer.__proto__ = Node;
	JSXExpressionContainer.prototype = Object.create( Node && Node.prototype );
	JSXExpressionContainer.prototype.constructor = JSXExpressionContainer;

	JSXExpressionContainer.prototype.transpile = function transpile ( code, transforms ) {
		code.remove( this.start, this.expression.start );
		code.remove( this.expression.end, this.end );

		Node.prototype.transpile.call( this, code, transforms );
	};

	return JSXExpressionContainer;
}(Node));

var JSXOpeningElement = (function (Node) {
	function JSXOpeningElement () {
		Node.apply(this, arguments);
	}

	if ( Node ) JSXOpeningElement.__proto__ = Node;
	JSXOpeningElement.prototype = Object.create( Node && Node.prototype );
	JSXOpeningElement.prototype.constructor = JSXOpeningElement;

	JSXOpeningElement.prototype.transpile = function transpile ( code, transforms ) {
		var this$1 = this;

		code.overwrite( this.start, this.name.start, ((this.program.jsx) + "( ") );

		var html = this.name.type === 'JSXIdentifier' && this.name.name[0] === this.name.name[0].toLowerCase();
		if ( html ) code.insertRight( this.name.start, "'" );

		var len = this.attributes.length;
		var c = this.name.end;

		if ( len ) {
			var i;

			var hasSpread = false;
			for ( i = 0; i < len; i += 1 ) {
				if ( this$1.attributes[i].type === 'JSXSpreadAttribute' ) {
					hasSpread = true;
					break;
				}
			}

			c = this.attributes[0].end;

			for ( i = 0; i < len; i += 1 ) {
				var attr = this$1.attributes[i];

				if ( i > 0 ) {
					code.overwrite( c, attr.start, ', ' );
				}

				if ( hasSpread && attr.type !== 'JSXSpreadAttribute' ) {
					var lastAttr = this$1.attributes[ i - 1 ];
					var nextAttr = this$1.attributes[ i + 1 ];

					if ( !lastAttr || lastAttr.type === 'JSXSpreadAttribute' ) {
						code.insertRight( attr.start, '{ ' );
					}

					if ( !nextAttr || nextAttr.type === 'JSXSpreadAttribute' ) {
						code.insertLeft( attr.end, ' }' );
					}
				}

				c = attr.end;
			}

			var after;
			var before;
			if ( hasSpread ) {
				if ( len === 1 ) {
					before = html ? "'," : ',';
				} else {
					before = html ? "', Object.assign({}," : ', Object.assign({},';
					after = ')';
				}
			} else {
				before = html ? "', {" : ', {';
				after = ' }';
			}

			code.insertRight( this.name.end, before );

			if ( after ) {
				code.insertLeft( this.attributes[ len - 1 ].end, after );
			}
		} else {
			code.insertLeft( this.name.end, html ? "', null" : ", null" );
			c = this.name.end;
		}

		Node.prototype.transpile.call( this, code, transforms );

		if ( this.selfClosing ) {
			code.overwrite( c, this.end, this.attributes.length ? ")" : " )" );
		} else {
			code.remove( c, this.end );
		}
	};

	return JSXOpeningElement;
}(Node));

var JSXSpreadAttribute = (function (Node) {
	function JSXSpreadAttribute () {
		Node.apply(this, arguments);
	}

	if ( Node ) JSXSpreadAttribute.__proto__ = Node;
	JSXSpreadAttribute.prototype = Object.create( Node && Node.prototype );
	JSXSpreadAttribute.prototype.constructor = JSXSpreadAttribute;

	JSXSpreadAttribute.prototype.transpile = function transpile ( code, transforms ) {
		code.remove( this.start, this.argument.start );
		code.remove( this.argument.end, this.end );

		Node.prototype.transpile.call( this, code, transforms );
	};

	return JSXSpreadAttribute;
}(Node));

var Literal = (function (Node) {
	function Literal () {
		Node.apply(this, arguments);
	}

	if ( Node ) Literal.__proto__ = Node;
	Literal.prototype = Object.create( Node && Node.prototype );
	Literal.prototype.constructor = Literal;

	Literal.prototype.transpile = function transpile ( code, transforms ) {
		if ( transforms.numericLiteral ) {
			var leading = this.raw.slice( 0, 2 );
			if ( leading === '0b' || leading === '0o' ) {
				code.overwrite( this.start, this.end, String( this.value ), true );
			}
		}

		if ( this.regex ) {
			if ( transforms.unicodeRegExp && /u/.test( this.regex.flags ) ) throw new CompileError( this, 'Regular expression unicode flag is not supported' );
			if ( transforms.stickyRegExp && /y/.test( this.regex.flags ) ) throw new CompileError( this, 'Regular expression sticky flag is not supported' );
		}
	};

	return Literal;
}(Node));

var reserved = Object.create( null );
'do if in for let new try var case else enum eval null this true void with await break catch class const false super throw while yield delete export import public return static switch typeof default extends finally package private continue debugger function arguments interface protected implements instanceof'.split( ' ' )
	.forEach( function ( word ) { return reserved[ word ] = true; } );

var MemberExpression = (function (Node) {
	function MemberExpression () {
		Node.apply(this, arguments);
	}

	if ( Node ) MemberExpression.__proto__ = Node;
	MemberExpression.prototype = Object.create( Node && Node.prototype );
	MemberExpression.prototype.constructor = MemberExpression;

	MemberExpression.prototype.transpile = function transpile ( code, transforms ) {
		if ( transforms.reservedProperties && reserved[ this.property.name ] ) {
			code.overwrite( this.object.end, this.property.start, "['" );
			code.insertLeft( this.property.end, "']" );
		}

		Node.prototype.transpile.call( this, code, transforms );
	};

	return MemberExpression;
}(Node));

var ObjectExpression = (function (Node) {
	function ObjectExpression () {
		Node.apply(this, arguments);
	}

	if ( Node ) ObjectExpression.__proto__ = Node;
	ObjectExpression.prototype = Object.create( Node && Node.prototype );
	ObjectExpression.prototype.constructor = ObjectExpression;

	ObjectExpression.prototype.transpile = function transpile ( code, transforms ) {
		var this$1 = this;

		Node.prototype.transpile.call( this, code, transforms );

		var hasSpread = false;

		for ( var i$1 = 0, list = this.properties; i$1 < list.length; i$1 += 1 ) {
			var prop = list[i$1];

			if ( prop.type === 'SpreadProperty' ) {
				hasSpread = true;
				break;
			}
		}

		if ( hasSpread ) {
			// enclose run of non-spread properties in curlies
			var i = this.properties.length;
			while ( i-- ) {
				var prop$1 = this$1.properties[i];


				if ( prop$1.type === 'Property' ) {
					var lastProp = this$1.properties[ i - 1 ];
					var nextProp = this$1.properties[ i + 1 ];

					if ( !lastProp || lastProp.type !== 'Property' ) {
						code.insertRight( prop$1.start, '{' );
					}

					if ( !nextProp || nextProp.type !== 'Property' ) {
						code.insertLeft( prop$1.end, '}' );
					}
				}
			}

			// wrap the whole thing in Object.assign
			code.overwrite( this.start, this.properties[0].start, 'Object.assign({}, ');
			code.overwrite( this.properties[ this.properties.length - 1 ].end, this.end, ')' );
		}
	};

	return ObjectExpression;
}(Node));

var Property = (function (Node) {
	function Property () {
		Node.apply(this, arguments);
	}

	if ( Node ) Property.__proto__ = Node;
	Property.prototype = Object.create( Node && Node.prototype );
	Property.prototype.constructor = Property;

	Property.prototype.initialise = function initialise ( transforms ) {
		if ( this.computed && transforms.computedProperty ) {
			throw new CompileError( this.key, 'Computed properties are not supported' );
		}

		Node.prototype.initialise.call( this, transforms );
	};

	Property.prototype.transpile = function transpile ( code, transforms ) {
		if ( transforms.conciseMethodProperty && this.parent.type !== 'ObjectPattern' ) {
			if ( this.shorthand ) {
				code.insertRight( this.start, ((this.key.name) + ": ") );
			} else if ( this.method ) {
				var name = this.findScope( true ).createIdentifier( this.key.name );
				if ( this.value.generator ) code.remove( this.start, this.key.start );
				code.insertLeft( this.key.end, (": function" + (this.value.generator ? '*' : '') + " " + name) );
			}
		}

		if ( transforms.reservedProperties && reserved[ this.key.name ] ) {
			code.insertRight( this.key.start, "'" );
			code.insertLeft( this.key.end, "'" );
		}

		Node.prototype.transpile.call( this, code, transforms );
	};

	return Property;
}(Node));

var ReturnStatement = (function (Node) {
	function ReturnStatement () {
		Node.apply(this, arguments);
	}

	if ( Node ) ReturnStatement.__proto__ = Node;
	ReturnStatement.prototype = Object.create( Node && Node.prototype );
	ReturnStatement.prototype.constructor = ReturnStatement;

	ReturnStatement.prototype.initialise = function initialise ( transforms ) {
		this.loop = this.findNearest( /(?:For(?:In)?|While)Statement/ );
		this.nearestFunction = this.findNearest( /Function/ );

		if ( this.loop && ( !this.nearestFunction || this.loop.depth > this.nearestFunction.depth ) ) {
			this.loop.canReturn = true;
			this.shouldWrap = true;
		}

		if ( this.argument ) this.argument.initialise( transforms );
	};

	ReturnStatement.prototype.transpile = function transpile ( code, transforms ) {
		if ( this.argument ) {
			var shouldWrap = this.shouldWrap && this.loop && this.loop.shouldRewriteAsFunction;

			if ( shouldWrap ) code.insertRight( this.argument.start, "{ v: " );

			if ( this.argument ) this.argument.transpile( code, transforms );

			if ( shouldWrap ) code.insertLeft( this.argument.end, " }" );
		}
	};

	return ReturnStatement;
}(Node));

var SpreadProperty = (function (Node) {
	function SpreadProperty () {
		Node.apply(this, arguments);
	}

	if ( Node ) SpreadProperty.__proto__ = Node;
	SpreadProperty.prototype = Object.create( Node && Node.prototype );
	SpreadProperty.prototype.constructor = SpreadProperty;

	SpreadProperty.prototype.transpile = function transpile ( code, transforms ) {
		code.remove( this.start, this.argument.start );
		code.remove( this.argument.end, this.end );

		Node.prototype.transpile.call( this, code, transforms );
	};

	return SpreadProperty;
}(Node));

var Super = (function (Node) {
	function Super () {
		Node.apply(this, arguments);
	}

	if ( Node ) Super.__proto__ = Node;
	Super.prototype = Object.create( Node && Node.prototype );
	Super.prototype.constructor = Super;

	Super.prototype.initialise = function initialise ( transforms ) {
		if ( transforms.classes ) {
			this.method = this.findNearest( 'MethodDefinition' );
			if ( !this.method ) throw new CompileError( this, 'use of super outside class method' );

			var parentClass = this.findNearest( 'ClassBody' ).parent;
			this.superClassName = parentClass.superClass && (parentClass.superClass.name || 'superclass');

			if ( !this.superClassName ) throw new CompileError( this, 'super used in base class' );

			this.isCalled = this.parent.type === 'CallExpression' && this === this.parent.callee;

			if ( this.method.kind !== 'constructor' && this.isCalled ) {
				throw new CompileError( this, 'super() not allowed outside class constructor' );
			}

			this.isMember = this.parent.type === 'MemberExpression';

			if ( !this.isCalled && !this.isMember ) {
				throw new CompileError( this, 'Unexpected use of `super` (expected `super(...)` or `super.*`)' );
			}
		}
	};

	Super.prototype.transpile = function transpile ( code, transforms ) {
		if ( transforms.classes ) {
			var expression = ( this.isCalled || this.method.static ) ?
				this.superClassName :
				((this.superClassName) + ".prototype");

			code.overwrite( this.start, this.end, expression, true );

			var callExpression = this.isCalled ? this.parent : this.parent.parent;

			if ( callExpression && callExpression.type === 'CallExpression' ) {
				code.insertLeft( callExpression.callee.end, '.call' );

				if ( callExpression.arguments.length ) {
					code.insertLeft( callExpression.arguments[0].start, "this, " );
				} else {
					code.insertLeft( callExpression.end - 1, "this" );
				}
			}
		}
	};

	return Super;
}(Node));

var TaggedTemplateExpression = (function (Node) {
	function TaggedTemplateExpression () {
		Node.apply(this, arguments);
	}

	if ( Node ) TaggedTemplateExpression.__proto__ = Node;
	TaggedTemplateExpression.prototype = Object.create( Node && Node.prototype );
	TaggedTemplateExpression.prototype.constructor = TaggedTemplateExpression;

	TaggedTemplateExpression.prototype.initialise = function initialise ( transforms ) {
		if ( transforms.templateString && !transforms.dangerousTaggedTemplateString ) {
			throw new CompileError( this, 'Tagged template strings are not supported. Use `transforms: { templateString: false }` to skip transformation and disable this error, or `transforms: { dangerousTaggedTemplateString: true }` if you know what you\'re doing' );
		}

		Node.prototype.initialise.call( this, transforms );
	};

	TaggedTemplateExpression.prototype.transpile = function transpile ( code, transforms ) {
		if ( transforms.templateString && transforms.dangerousTaggedTemplateString ) {
			var ordered = this.quasi.expressions.concat( this.quasi.quasis ).sort( function ( a, b ) { return a.start - b.start; } );

			// insert strings at start
			var templateStrings = this.quasi.quasis.map( function ( quasi ) { return JSON.stringify( quasi.value.cooked ); } );
			code.overwrite( this.tag.end, ordered[0].start, ("([" + (templateStrings.join(', ')) + "]") );

			var lastIndex = ordered[0].start;
			ordered.forEach( function ( node ) {
				if ( node.type === 'TemplateElement' ) {
					code.remove( lastIndex, node.end );
				} else {
					code.overwrite( lastIndex, node.start, ', ' );
				}

				lastIndex = node.end;
			});

			code.overwrite( lastIndex, this.end, ')' );
		}

		Node.prototype.transpile.call( this, code, transforms );
	};

	return TaggedTemplateExpression;
}(Node));

var TemplateElement = (function (Node) {
	function TemplateElement () {
		Node.apply(this, arguments);
	}

	if ( Node ) TemplateElement.__proto__ = Node;
	TemplateElement.prototype = Object.create( Node && Node.prototype );
	TemplateElement.prototype.constructor = TemplateElement;

	TemplateElement.prototype.initialise = function initialise ( transforms ) {
		this.program.templateElements.push( this );
	};

	return TemplateElement;
}(Node));

var TemplateLiteral = (function (Node) {
	function TemplateLiteral () {
		Node.apply(this, arguments);
	}

	if ( Node ) TemplateLiteral.__proto__ = Node;
	TemplateLiteral.prototype = Object.create( Node && Node.prototype );
	TemplateLiteral.prototype.constructor = TemplateLiteral;

	TemplateLiteral.prototype.transpile = function transpile ( code, transforms ) {
		if ( transforms.templateString && this.parent.type !== 'TaggedTemplateExpression' ) {
			var ordered = this.expressions.concat( this.quasis )
				.sort( function ( a, b ) { return a.start - b.start || a.end - b.end; } )
				.filter( function ( node, i ) {
					// include all expressions
					if ( node.type !== 'TemplateElement' ) return true;

					// include all non-empty strings
					if ( node.value.raw ) return true;

					// exclude all empty strings not at the head
					return !i;
				});

			// special case – we may be able to skip the first element,
			// if it's the empty string, but only if the second and
			// third elements aren't both expressions (since they maybe
			// be numeric, and `1 + 2 + '3' === '33'`)
			if ( ordered.length >= 3 ) {
				var first = ordered[0];
				var third = ordered[2];
				if ( first.type === 'TemplateElement' && first.value.raw === '' && third.type === 'TemplateElement' ) {
					ordered.shift();
				}
			}

			var parenthesise = ( this.quasis.length !== 1 || this.expressions.length !== 0 ) &&
			                     this.parent.type !== 'AssignmentExpression' &&
			                     this.parent.type !== 'VariableDeclarator' &&
			                     ( this.parent.type !== 'BinaryExpression' || this.parent.operator !== '+' );

			if ( parenthesise ) code.insertRight( this.start, '(' );

			var lastIndex = this.start;

			ordered.forEach( function ( node, i ) {
				if ( node.type === 'TemplateElement' ) {
					var replacement = '';
					if ( i ) replacement += ' + ';
					replacement += JSON.stringify( node.value.cooked );

					code.overwrite( lastIndex, node.end, replacement );
				} else {
					var parenthesise = node.type !== 'Identifier'; // TODO other cases where it's safe

					var replacement$1 = '';
					if ( i ) replacement$1 += ' + ';
					if ( parenthesise ) replacement$1 += '(';

					code.overwrite( lastIndex, node.start, replacement$1 );

					if ( parenthesise ) code.insertLeft( node.end, ')' );
				}

				lastIndex = node.end;
			});

			var close = '';
			if ( parenthesise ) close += ')';

			code.overwrite( lastIndex, this.end, close );
		}

		Node.prototype.transpile.call( this, code, transforms );
	};

	return TemplateLiteral;
}(Node));

var ThisExpression = (function (Node) {
	function ThisExpression () {
		Node.apply(this, arguments);
	}

	if ( Node ) ThisExpression.__proto__ = Node;
	ThisExpression.prototype = Object.create( Node && Node.prototype );
	ThisExpression.prototype.constructor = ThisExpression;

	ThisExpression.prototype.initialise = function initialise ( transforms ) {
		if ( transforms.arrow ) {
			var lexicalBoundary = this.findLexicalBoundary();
			var arrowFunction = this.findNearest( 'ArrowFunctionExpression' );
			var loop = this.findNearest( /(?:For(?:In|Of)?|While)Statement/ );

			if ( arrowFunction && arrowFunction.depth > lexicalBoundary.depth ) {
				this.alias = lexicalBoundary.getThisAlias();
			}

			if ( loop && loop.body.contains( this ) && loop.depth > lexicalBoundary.depth ) {
				this.alias = lexicalBoundary.getThisAlias();
			}
		}
	};

	ThisExpression.prototype.transpile = function transpile ( code, transforms ) {
		if ( this.alias ) {
			code.overwrite( this.start, this.end, this.alias, true );
		}
	};

	return ThisExpression;
}(Node));

var UpdateExpression = (function (Node) {
	function UpdateExpression () {
		Node.apply(this, arguments);
	}

	if ( Node ) UpdateExpression.__proto__ = Node;
	UpdateExpression.prototype = Object.create( Node && Node.prototype );
	UpdateExpression.prototype.constructor = UpdateExpression;

	UpdateExpression.prototype.initialise = function initialise ( transforms ) {
		if ( this.argument.type === 'Identifier' ) {
			var declaration = this.findScope( false ).findDeclaration( this.argument.name );
			if ( declaration && declaration.kind === 'const' ) {
				throw new CompileError( this, ((this.argument.name) + " is read-only") );
			}
		}

		Node.prototype.initialise.call( this, transforms );
	};

	return UpdateExpression;
}(Node));

var handlers = {
	ArrayPattern: destructureArrayPattern,
	ObjectPattern: destructureObjectPattern,
	AssignmentPattern: destructureAssignmentPattern
};

function destructure ( code, scope, node, ref, statementGenerators ) {
	var handler = handlers[ node.type ];
	if ( !handler ) throw new Error( ("not implemented: " + (node.type)) );

	handler( code, scope, node, ref, statementGenerators );
}

function handlePattern ( code, scope, node, tmp, expr, statementGenerators ) {
	if ( node.type === 'Identifier' ) {
		var declaration = scope.findDeclaration( node.name );

		statementGenerators.push( function ( start, prefix, suffix ) {
			code.insertRight( node.start, (prefix + "var ") );
			code.insertLeft( node.end, (" = " + expr + ";" + suffix) );
			code.move( node.start, node.end, start );
		});
	} else if ( node.type === 'AssignmentPattern' ) {
		statementGenerators.push( function ( start, prefix, suffix ) {
			code.remove( node.start, node.right.start );

			var name = node.left.name;
			code
				.insertRight( node.right.start, (prefix + "var " + tmp + " = " + expr + ", " + name + " = " + tmp + " === void 0 ? ") )
				.insertLeft( node.right.end, (" : " + tmp + ";" + suffix) )
				.move( node.right.start, node.right.end, start );
		});
	} else {
		throw new Error( 'Compound destructuring is not supported' );
	}
}

function destructureArrayPattern ( code, scope, node, ref, statementGenerators ) {
	var c = node.start;

	node.elements.forEach( function ( element, i ) {
		if ( !element ) return;

		code.remove( c, element.start );
		handlePattern( code, scope, element, scope.createIdentifier( (ref + "_" + i) ), (ref + "[" + i + "]"), statementGenerators );
		c = element.end;
	});

	code.remove( c, node.end );
}

function destructureObjectPattern ( code, scope, node, ref, statementGenerators ) {
	var c = node.start;

	node.properties.forEach( function ( prop ) {
		var key = prop.key.name;

		code.remove( c, prop.value.start );
		handlePattern( code, scope, prop.value, scope.createIdentifier( (ref + "_" + key) ), (ref + "." + key), statementGenerators );
		c = prop.end;
	});

	code.remove( c, node.end );
}

function destructureAssignmentPattern ( code, scope, node, ref, statementGenerators ) {
	var isIdentifier = node.left.type === 'Identifier';
	var name = isIdentifier ? node.left.name : ref;

	statementGenerators.push( function ( start, prefix, suffix ) {
		code.insertRight( node.left.end, (prefix + "if ( " + name + " === void 0 ) " + name) );
		code.move( node.left.end, node.right.end, start );
		code.insertLeft( node.right.end, (";" + suffix) );
	});

	if ( !isIdentifier ) {
		destructure( code, scope, node.left, ref, statementGenerators );
	}
}

var VariableDeclaration = (function (Node) {
	function VariableDeclaration () {
		Node.apply(this, arguments);
	}

	if ( Node ) VariableDeclaration.__proto__ = Node;
	VariableDeclaration.prototype = Object.create( Node && Node.prototype );
	VariableDeclaration.prototype.constructor = VariableDeclaration;

	VariableDeclaration.prototype.initialise = function initialise ( transforms ) {
		this.scope = this.findScope( this.kind === 'var' );
		this.declarations.forEach( function ( declarator ) { return declarator.initialise( transforms ); } );
	};

	VariableDeclaration.prototype.transpile = function transpile ( code, transforms ) {
		var this$1 = this;

		var i0 = this.getIndentation();
		var kind = this.kind;

		if ( transforms.letConst && kind !== 'var' ) {
			kind = 'var';
			code.overwrite( this.start, this.start + this.kind.length, kind, true );
		}

		if ( transforms.destructuring ) {
			var c = this.start;
			var lastDeclaratorIsPattern;

			this.declarations.forEach( function ( declarator, i ) {
				if ( declarator.id.type === 'Identifier' ) {
					if ( i > 0 && this$1.declarations[ i - 1 ].id.type !== 'Identifier' ) {
						code.overwrite( c, declarator.id.start, "var " );
					}
				} else {
					if ( i === 0 ) {
						code.remove( c, declarator.id.start );
					} else {
						code.overwrite( c, declarator.id.start, (";\n" + i0) );
					}

					var simple = declarator.init.type === 'Identifier' && !declarator.init.rewritten;

					var name = simple ? declarator.init.name : declarator.findScope( true ).createIdentifier( 'ref' );

					var c$1 = declarator.start;

					var statementGenerators = [];

					if ( simple ) {
						code.remove( declarator.id.end, declarator.end );
					} else {
						statementGenerators.push( function ( start, prefix, suffix ) {
							code.insertRight( declarator.id.end, ("var " + name) );
							code.insertLeft( declarator.init.end, (";" + suffix) );
							code.move( declarator.id.end, declarator.end, start );
						});
					}

					destructure( code, declarator.findScope( true ), declarator.id, name, statementGenerators );

					var suffix = "\n" + i0;
					statementGenerators.forEach( function ( fn, j ) {
						if ( i === this$1.declarations.length - 1 && j === statementGenerators.length - 1 ) {
							suffix = '';
						}

						fn( declarator.start, "", suffix );
					});
				}

				if ( declarator.init ) {
					declarator.init.transpile( code, transforms );
				}

				c = declarator.end;
				lastDeclaratorIsPattern = declarator.id.type !== 'Identifier';
			});

			if ( lastDeclaratorIsPattern ) {
				code.remove( c, this.end );
			}
		}

		else {
			this.declarations.forEach( function ( declarator ) {
				if ( declarator.init ) declarator.init.transpile( code, transforms );
			});
		}

	};

	return VariableDeclaration;
}(Node));

var VariableDeclarator = (function (Node) {
	function VariableDeclarator () {
		Node.apply(this, arguments);
	}

	if ( Node ) VariableDeclarator.__proto__ = Node;
	VariableDeclarator.prototype = Object.create( Node && Node.prototype );
	VariableDeclarator.prototype.constructor = VariableDeclarator;

	VariableDeclarator.prototype.initialise = function initialise ( transforms ) {
		var kind = this.parent.kind;
		if ( kind === 'let' && this.parent.parent.type === 'ForStatement' ) {
			kind = 'for.let'; // special case...
		}

		this.parent.scope.addDeclaration( this.id, kind );
		Node.prototype.initialise.call( this, transforms );
	};

	return VariableDeclarator;
}(Node));

var types = {
	ArrayExpression: ArrayExpression,
	ArrowFunctionExpression: ArrowFunctionExpression,
	AssignmentExpression: AssignmentExpression,
	BinaryExpression: BinaryExpression,
	BreakStatement: BreakStatement,
	CallExpression: CallExpression,
	ClassBody: ClassBody,
	ClassDeclaration: ClassDeclaration,
	ClassExpression: ClassExpression,
	ContinueStatement: ContinueStatement,
	DoWhileStatement: LoopStatement,
	ExportNamedDeclaration: ExportNamedDeclaration,
	ExportDefaultDeclaration: ExportDefaultDeclaration,
	ForStatement: ForStatement,
	ForInStatement: ForInStatement,
	ForOfStatement: ForOfStatement,
	FunctionDeclaration: FunctionDeclaration,
	FunctionExpression: FunctionExpression,
	Identifier: Identifier,
	ImportDeclaration: ImportDeclaration,
	ImportDefaultSpecifier: ImportDefaultSpecifier,
	ImportSpecifier: ImportSpecifier,
	JSXAttribute: JSXAttribute,
	JSXClosingElement: JSXClosingElement,
	JSXElement: JSXElement,
	JSXExpressionContainer: JSXExpressionContainer,
	JSXOpeningElement: JSXOpeningElement,
  JSXSpreadAttribute: JSXSpreadAttribute,
	Literal: Literal,
	MemberExpression: MemberExpression,
	ObjectExpression: ObjectExpression,
	Property: Property,
	ReturnStatement: ReturnStatement,
	SpreadProperty: SpreadProperty,
	Super: Super,
	TaggedTemplateExpression: TaggedTemplateExpression,
	TemplateElement: TemplateElement,
	TemplateLiteral: TemplateLiteral,
	ThisExpression: ThisExpression,
	UpdateExpression: UpdateExpression,
	VariableDeclaration: VariableDeclaration,
	VariableDeclarator: VariableDeclarator,
	WhileStatement: LoopStatement
};

var statementsWithBlocks = {
	IfStatement: 'consequent',
	ForStatement: 'body',
	ForInStatement: 'body',
	ForOfStatement: 'body',
	WhileStatement: 'body',
	DoWhileStatement: 'body',
	ArrowFunctionExpression: 'body'
};

function wrap ( raw, parent ) {
	if ( !raw ) return;

	if ( 'length' in raw ) {
		var i = raw.length;
		while ( i-- ) wrap( raw[i], parent );
		return;
	}

	// with e.g. shorthand properties, key and value are
	// the same node. We don't want to wrap an object twice
	if ( raw.__wrapped ) return;
	raw.__wrapped = true;

	if ( !keys[ raw.type ] ) {
		keys[ raw.type ] = Object.keys( raw ).filter( function ( key ) { return typeof raw[ key ] === 'object'; } );
	}

	// special case – body-less if/for/while statements. TODO others?
	var bodyType = statementsWithBlocks[ raw.type ];
	if ( bodyType && raw[ bodyType ].type !== 'BlockStatement' ) {
		var expression = raw[ bodyType ];

		// create a synthetic block statement, otherwise all hell
		// breaks loose when it comes to block scoping
		raw[ bodyType ] = {
			start: expression.start,
			end: expression.end,
			type: 'BlockStatement',
			body: [ expression ],
			synthetic: true
		};
	}

	Node( raw, parent );

	var type = ( raw.type === 'BlockStatement' ? BlockStatement : types[ raw.type ] ) || Node;
	raw.__proto__ = type.prototype;
}

var letConst = /^(?:let|const)$/;

function Scope ( options ) {
	options = options || {};

	this.parent = options.parent;
	this.isBlockScope = !!options.block;

	var scope = this;
	while ( scope.isBlockScope ) scope = scope.parent;
	this.functionScope = scope;

	this.declarations = Object.create( null );
	this.references = Object.create( null );
	this.blockScopedDeclarations = this.isBlockScope ? null : Object.create( null );
	this.aliases = this.isBlockScope ? null : Object.create( null );
}

Scope.prototype = {
	addDeclaration: function addDeclaration ( node, kind ) {
		for ( var i = 0, list = extractNames( node ); i < list.length; i += 1 ) {
			var identifier = list[i];

			var name = identifier.name;
			var existingDeclaration = this.declarations[ name ];
			if ( existingDeclaration && ( letConst.test( kind ) || letConst.test( existingDeclaration.kind ) ) ) {
				// TODO warn about double var declarations?
				throw new CompileError( identifier, (name + " is already declared") );
			}

			var declaration = { name: name, node: identifier, kind: kind, instances: [] };
			this.declarations[ name ] = declaration;

			if ( this.isBlockScope ) {
				if ( !this.functionScope.blockScopedDeclarations[ name ] ) this.functionScope.blockScopedDeclarations[ name ] = [];
				this.functionScope.blockScopedDeclarations[ name ].push( declaration );
			}
		}
	},

	addReference: function addReference ( identifier ) {
		var declaration = this.declarations[ identifier.name ];
		if ( declaration ) {
			declaration.instances.push( identifier );
		} else {
			this.references[ identifier.name ] = true;
			if ( this.parent ) this.parent.addReference( identifier );
		}
	},

	contains: function contains ( name ) {
		return this.declarations[ name ] ||
		       ( this.parent ? this.parent.contains( name ) : false );
	},

	createIdentifier: function createIdentifier ( base ) {
		var this$1 = this;

		var name = base;
		var counter = 1;

		while ( this$1.declarations[ name ] || this$1.references[ name ] || this$1.aliases[ name ] || name in reserved ) {
			name = base + "$" + (counter++);
		}

		this.aliases[ name ] = true;
		return name;
	},

	findDeclaration: function findDeclaration ( name ) {
		return this.declarations[ name ] ||
		       ( this.parent && this.parent.findDeclaration( name ) );
	}
};

var BlockStatement = (function (Node) {
	function BlockStatement () {
		Node.apply(this, arguments);
	}

	if ( Node ) BlockStatement.__proto__ = Node;
	BlockStatement.prototype = Object.create( Node && Node.prototype );
	BlockStatement.prototype.constructor = BlockStatement;

	BlockStatement.prototype.createScope = function createScope () {
		var this$1 = this;

		this.parentIsFunction = /Function/.test( this.parent.type );
		this.isFunctionBlock = this.parentIsFunction || this.parent.type === 'Root';
		this.scope = new Scope({
			block: !this.isFunctionBlock,
			parent: this.parent.findScope( false )
		});

		if ( this.parentIsFunction ) {
			this.parent.params.forEach( function ( node ) {
				this$1.scope.addDeclaration( node, 'param' );
			});
		}
	};

	BlockStatement.prototype.initialise = function initialise ( transforms ) {
		this.thisAlias = null;
		this.argumentsAlias = null;
		this.defaultParameters = [];

		// normally the scope gets created here, during initialisation,
		// but in some cases (e.g. `for` statements), we need to create
		// the scope early, as it pertains to both the init block and
		// the body of the statement
		if ( !this.scope ) this.createScope();

		this.body.forEach( function ( node ) { return node.initialise( transforms ); } );
	};

	BlockStatement.prototype.findLexicalBoundary = function findLexicalBoundary () {
		if ( this.type === 'Program' ) return this;
		if ( /^Function/.test( this.parent.type ) ) return this;

		return this.parent.findLexicalBoundary();
	};

	BlockStatement.prototype.findScope = function findScope ( functionScope ) {
		if ( functionScope && !this.isFunctionBlock ) return this.parent.findScope( functionScope );
		return this.scope;
	};

	BlockStatement.prototype.getArgumentsAlias = function getArgumentsAlias () {
		if ( !this.argumentsAlias ) {
			this.argumentsAlias = this.scope.createIdentifier( 'arguments' );
		}

		return this.argumentsAlias;
	};

	BlockStatement.prototype.getArgumentsArrayAlias = function getArgumentsArrayAlias () {
		if ( !this.argumentsArrayAlias ) {
			this.argumentsArrayAlias = this.scope.createIdentifier( 'argsArray' );
		}

		return this.argumentsArrayAlias;
	};

	BlockStatement.prototype.getThisAlias = function getThisAlias () {
		if ( !this.thisAlias ) {
			this.thisAlias = this.scope.createIdentifier( 'this' );
		}

		return this.thisAlias;
	};

	BlockStatement.prototype.getIndentation = function getIndentation () {
		var this$1 = this;

		if ( this.indentation === undefined ) {
			var source = this.program.magicString.original;

			var useOuter = this.synthetic || !this.body.length;
			var c = useOuter ? this.start : this.body[0].start;

			while ( c && source[c] !== '\n' ) c -= 1;

			this.indentation = '';

			while ( true ) {
				c += 1;
				var char = source[c];

				if ( char !== ' ' && char !== '\t' ) break;

				this$1.indentation += char;
			}

			var indentString = this.program.magicString.getIndentString();

			// account for dedented class constructors
			var parent = this.parent;
			while ( parent ) {
				if ( parent.kind === 'constructor' && !parent.parent.parent.superClass ) {
					this$1.indentation = this$1.indentation.replace( indentString, '' );
				}

				parent = parent.parent;
			}

			if ( useOuter ) this.indentation += indentString;
		}

		return this.indentation;
	};

	BlockStatement.prototype.transpile = function transpile ( code, transforms ) {
		var this$1 = this;

		var start = this.parent.type === 'Root' || this.synthetic ? this.start : this.start + 1;

		var indentation = this.getIndentation();

		var introStatementGenerators = [];

		if ( this.argumentsAlias ) {
			introStatementGenerators.push( function ( start, prefix, suffix ) {
				var assignment = prefix + "var " + (this$1.argumentsAlias) + " = arguments;" + suffix;
				code.insertLeft( start, assignment );
			});
		}

		if ( this.thisAlias ) {
			introStatementGenerators.push( function ( start, prefix, suffix ) {
				var assignment = prefix + "var " + (this$1.thisAlias) + " = this;" + suffix;
				code.insertLeft( start, assignment );
			});
		}

		if ( this.argumentsArrayAlias ) {
			introStatementGenerators.push( function ( start, prefix, suffix ) {
				var i = this$1.scope.createIdentifier( 'i' );
				var assignment = prefix + "var " + i + " = arguments.length, " + (this$1.argumentsArrayAlias) + " = Array(" + i + ");\n" + indentation + "while ( " + i + "-- ) " + (this$1.argumentsArrayAlias) + "[" + i + "] = arguments[" + i + "];" + suffix;
				code.insertLeft( start, assignment );
			});
		}

		if ( /Function/.test( this.parent.type ) ) {
			this.transpileParameters( code, transforms, indentation, introStatementGenerators );
		}

		if ( transforms.letConst && this.isFunctionBlock ) {
			this.transpileBlockScopedIdentifiers( code );
		}

		Node.prototype.transpile.call( this, code, transforms );

		if ( this.synthetic ) {
			if ( this.parent.type === 'ArrowFunctionExpression' ) {
				var expr = this.body[0];

				if ( introStatementGenerators.length ) {
					code.insertLeft( this.start, "{" ).insertRight( this.end, ((this.parent.getIndentation()) + "}") );

					code.insertRight( expr.start, ("\n" + indentation + "return ") );
					code.insertLeft( expr.end, ";\n" );
				} else if ( transforms.arrow ) {
					code.insertRight( expr.start, "{ return " );
					code.insertLeft( expr.end, "; }" );
				}
			}

			else if ( introStatementGenerators.length ) {
				code.insertLeft( this.start, "{" ).insertRight( this.end, "}" );
			}
		}

		var prefix = "\n" + indentation;
		var suffix = '';
		introStatementGenerators.forEach( function ( fn, i ) {
			if ( i === introStatementGenerators.length - 1 ) suffix = ( this$1.parent.type === 'Root' ? "\n" : "\n" );
			fn( start, prefix, suffix );
		});
	};

	BlockStatement.prototype.transpileParameters = function transpileParameters ( code, transforms, indentation, introStatementGenerators ) {
		var this$1 = this;

		var params = this.parent.params;

		params.forEach( function ( param ) {
			if ( param.type === 'AssignmentPattern' && param.left.type === 'Identifier' ) {
				if ( transforms.defaultParameter ) {
					introStatementGenerators.push( function ( start, prefix, suffix ) {
						var lhs = prefix + "if ( " + (param.left.name) + " === void 0 ) " + (param.left.name);

						code
							.insertRight( param.left.end, ("" + lhs) )
							.move( param.left.end, param.right.end, start )
							.insertLeft( param.right.end, (";" + suffix) );
					});
				}
			}

			else if ( param.type === 'RestElement' ) {
				if ( transforms.spreadRest ) {
					introStatementGenerators.push( function ( start, prefix, suffix ) {
						var penultimateParam = params[ params.length - 2 ];

						if ( penultimateParam ) {
							code.remove( penultimateParam ? penultimateParam.end : param.start, param.end );
						} else {
							var start$1 = param.start, end = param.end; // TODO https://gitlab.com/Rich-Harris/buble/issues/8

							while ( /\s/.test( code.original[ start$1 - 1 ] ) ) start$1 -= 1;
							while ( /\s/.test( code.original[ end ] ) ) end += 1;

							code.remove( start$1, end );
						}

						var name = param.argument.name;
						var len = this$1.scope.createIdentifier( 'len' );
						var count = params.length - 1;

						if ( count ) {
							code.insertLeft( start, (prefix + "var " + name + " = [], " + len + " = arguments.length - " + count + ";\n" + indentation + "while ( " + len + "-- > 0 ) " + name + "[ " + len + " ] = arguments[ " + len + " + " + count + " ];" + suffix) );
						} else {
							code.insertLeft( start, (prefix + "var " + name + " = [], " + len + " = arguments.length;\n" + indentation + "while ( " + len + "-- ) " + name + "[ " + len + " ] = arguments[ " + len + " ];" + suffix) );
						}
					});
				}
			}

			else if ( param.type !== 'Identifier' ) {
				if ( transforms.parameterDestructuring ) {
					var ref = this$1.scope.createIdentifier( 'ref' );
					destructure( code, this$1.scope, param, ref, introStatementGenerators );
					code.insertLeft( param.start, ref );
				}
			}
		});
	};

	BlockStatement.prototype.transpileBlockScopedIdentifiers = function transpileBlockScopedIdentifiers ( code ) {
		var this$1 = this;

		Object.keys( this.scope.blockScopedDeclarations ).forEach( function ( name ) {
			var declarations = this$1.scope.blockScopedDeclarations[ name ];

			for ( var i = 0; i < declarations.length; i += 1 ) {
				var declaration = declarations[i];
				var cont = false; // TODO implement proper continue...

				if ( declaration.kind === 'for.let' ) {
					// special case
					var forStatement = declaration.node.findNearest( 'ForStatement' );

					if ( forStatement.shouldRewriteAsFunction ) {
						var outerAlias = this$1.scope.createIdentifier( name );
						var innerAlias = forStatement.reassigned[ name ] ?
							this$1.scope.createIdentifier( name ) :
							name;

						declaration.name = outerAlias;
						code.overwrite( declaration.node.start, declaration.node.end, outerAlias, true );

						forStatement.aliases[ name ] = {
							outer: outerAlias,
							inner: innerAlias
						};

						for ( var i$1 = 0, list = declaration.instances; i$1 < list.length; i$1 += 1 ) {
							var identifier = list[i$1];

							var alias = forStatement.body.contains( identifier ) ?
								innerAlias :
								outerAlias;

							if ( name !== alias ) {
								code.overwrite( identifier.start, identifier.end, alias, true );
							}
						}

						cont = true;
					}
				}

				if ( !cont ) {
					var alias$1 = this$1.scope.createIdentifier( name );

					if ( name !== alias$1 ) {
						declaration.name = alias$1;
						code.overwrite( declaration.node.start, declaration.node.end, alias$1, true );

						for ( var i$2 = 0, list$1 = declaration.instances; i$2 < list$1.length; i$2 += 1 ) {
							var identifier$1 = list$1[i$2];

							identifier$1.rewritten = true;
							code.overwrite( identifier$1.start, identifier$1.end, alias$1, true );
						}
					}
				}
			}
		});
	};

	return BlockStatement;
}(Node));

function Program ( source, ast, transforms, options ) {
	var this$1 = this;

	this.type = 'Root';

	// options
	this.jsx = options.jsx || 'React.createElement';

	this.source = source;
	this.magicString = new MagicString( source );

	this.ast = ast;
	this.depth = 0;

	wrap( this.body = ast, this );
	this.body.__proto__ = BlockStatement.prototype;

	this.templateElements = [];
	this.body.initialise( transforms );

	this.indentExclusions = {};
	for ( var i$1 = 0, list = this.templateElements; i$1 < list.length; i$1 += 1 ) {
		var node = list[i$1];

		for ( var i = node.start; i < node.end; i += 1 ) {
			this$1.indentExclusions[ node.start + i ] = true;
		}
	}

	this.body.transpile( this.magicString, transforms );
}

Program.prototype = {
	export: function export$1 ( options ) {
		if ( options === void 0 ) options = {};

		return {
			code: this.magicString.toString(),
			map: this.magicString.generateMap({
				file: options.file,
				source: options.source,
				includeContent: options.includeContent !== false
			})
		};
	},

	findNearest: function findNearest () {
		return null;
	},

	findScope: function findScope () {
		return null;
	}
};

var matrix = {
	chrome: {
		    48: 1333689725,
		    49: 1342078975,
		    50: 1610514431
	},
	firefox: {
		    43: 1207307741,
		    44: 1207307741,
		    45: 1207307741
	},
	safari: {
		     8: 1073741824,
		     9: 1328940894
	},
	ie: {
		     8: 0,
		     9: 1073741824,
		    10: 1073741824,
		    11: 1073770592
	},
	edge: {
		    12: 1591620701,
		    13: 1608400479
	},
	node: {
		'0.10': 1075052608,
		'0.12': 1091830852,
		     4: 1327398527,
		     5: 1327398527,
		     6: 1610514431
	}
};

var features = [
	'arrow',
	'classes',
	'collections',
	'computedProperty',
	'conciseMethodProperty',
	'constLoop',
	'constRedef',
	'defaultParameter',
	'destructuring',
	'extendNatives',
	'forOf',
	'generator',
	'letConst',
	'letLoop',
	'letLoopScope',
	'moduleExport',
	'moduleImport',
	'numericLiteral',
	'objectProto',
	'objectSuper',
	'oldOctalLiteral',
	'parameterDestructuring',
	'spreadRest',
	'stickyRegExp',
	'symbol',
	'templateString',
	'unicodeEscape',
	'unicodeIdentifier',
	'unicodeRegExp',

	// ES2016
	'exponentiation',

	// additional transforms, not from
	// https://featuretests.io
	'reservedProperties'
];

var version = "0.10.6";

var acorn = acornObjectSpread(acornJsx);

var dangerousTransforms = [
	'dangerousTaggedTemplateString',
	'dangerousForOf'
];

function target ( target ) {
	var targets = Object.keys( target );
	var bitmask = targets.length ?
		2147483647 :
		1073741824;

	Object.keys( target ).forEach( function ( environment ) {
		var versions = matrix[ environment ];
		if ( !versions ) throw new Error( ("Unknown environment '" + environment + "'. Please raise an issue at https://gitlab.com/Rich-Harris/buble/issues") );

		var targetVersion = target[ environment ];
		if ( !( targetVersion in versions ) ) throw new Error( ("Support data exists for the following versions of " + environment + ": " + (Object.keys( versions ).join( ', ')) + ". Please raise an issue at https://gitlab.com/Rich-Harris/buble/issues") );
		var support = versions[ targetVersion ];

		bitmask &= support;
	});

	var transforms = Object.create( null );
	features.forEach( function ( name, i ) {
		transforms[ name ] = !( bitmask & 1 << i );
	});

	dangerousTransforms.forEach( function ( name ) {
		transforms[ name ] = false;
	});

	return transforms;
}

function transform ( source, options ) {
	if ( options === void 0 ) options = {};

	var ast;

	try {
		ast = acorn.parse( source, {
			ecmaVersion: 7,
			preserveParens: true,
			sourceType: 'module',
			plugins: {
				jsx: true,
				objectSpread: true
			}
		});
	} catch ( err ) {
		err.snippet = getSnippet( source, err.loc );
		throw err;
	}

	var transforms = target( options.target || {} );
	Object.keys( options.transforms || {} ).forEach( function ( name ) {
		if ( name === 'modules' ) {
			if ( !( 'moduleImport' in options.transforms ) ) transforms.moduleImport = options.transforms.modules;
			if ( !( 'moduleExport' in options.transforms ) ) transforms.moduleExport = options.transforms.modules;
			return;
		}

		if ( !( name in transforms ) ) throw new Error( ("Unknown transform '" + name + "'") );
		transforms[ name ] = options.transforms[ name ];
	});

	return new Program( source, ast, transforms, options ).export( options );
}

export { target, transform, version as VERSION };
//# sourceMappingURL=buble.es.js.map